var Block, Compiler, File, Promise, R, autoprefixer, browserify, fs, js, less, lessc, path, postcss, readFile, substitute, through;

fs = require('fs');

path = require('path');

lessc = require('less');

browserify = require('browserify');

Promise = require('bluebird');

through = require('through');

R = require('ramda');

autoprefixer = require('autoprefixer-core');

postcss = require('postcss');

Block = require('./block');

File = require('./file');

readFile = Promise.promisify(fs.readFile);

substitute = function(sub) {
  return function(str) {
    var regexp;
    if (sub != null) {
      regexp = new RegExp(sub.from, 'g');
      return str.replace(regexp, sub.to);
    } else {
      return str;
    }
  };
};

Compiler = (function() {
  function Compiler(compileFn) {
    this.compileFn = compileFn;
  }

  Compiler.prototype.run = function() {
    return this.compileFn.apply(this, arguments).then(function(output) {
      return Promise.map(output.files, function(path) {
        return File.mtime(path).then(function(mtime) {
          return {
            path: path,
            mtime: mtime
          };
        });
      }).then(function(files) {
        return {
          content: output.content,
          files: files
        };
      });
    });
  };

  return Compiler;

})();

less = (function() {
  var lessCompile, lessOptions, lessRender;
  lessRender = Promise.promisify(lessc.render);
  lessOptions = function(platform, filePath) {
    return {
      sourceMap: {
        sourceMapFileInline: true
      },
      paths: [path.dirname(filePath), path.join(path.resolve(filePath, '../../../'), 'const', platform), path.join(path.resolve(filePath, '../../../../'), 'const', platform)],
      filename: filePath,
      ieCompat: false
    };
  };
  lessCompile = function(opts, filePath) {
    return readFile(filePath, {
      encoding: 'utf-8'
    }).then(substitute(opts.substitute)).then(function(input) {
      return lessc.render(input, lessOptions(opts.platform, filePath));
    }).then(function(out) {
      return postcss([autoprefixer]).process(out.css).then(function(result) {
        return {
          content: result.css,
          files: [filePath].concat(out.imports)
        };
      });
    });
  };
  return new Compiler(lessCompile);
})();

js = (function() {
  var imagePaths, include2require, jsCompile, transformer;
  transformer = function(f) {
    return function() {
      var buffer, end, write;
      buffer = '';
      write = function(data) {
        return buffer += data;
      };
      end = function() {
        this.queue(f(buffer));
        return this.queue(null);
      };
      return through(write, end);
    };
  };
  include2require = transformer(function(js) {
    return js.replace(/\/\/= include (.+)/g, 'require(\'./$1\');');
  });
  imagePaths = function(filePath) {
    return transformer(function(js) {
      var blockPath, relPath;
      blockPath = path.resolve(filePath, '../../../..');
      relPath = path.relative(blockPath, path.resolve(filePath, '..'));
      return js.replace(/(['"])url\((?!\/)([^'"]+)\)/g, "$1url(/" + relPath + "/$2)");
    });
  };
  jsCompile = function(opts, filePath) {
    var files;
    files = [];
    return new Promise(function(resolve, reject) {
      return browserify({
        debug: true
      }).transform(transformer(substitute(opts.substitute))).transform(include2require).transform(imagePaths(filePath)).add(filePath).on('file', function(file) {
        return files.push(file);
      }).bundle(function(err, data) {
        if (err != null) {
          return reject(err);
        } else {
          return resolve({
            content: data.toString('utf-8'),
            files: files
          });
        }
      });
    });
  };
  return new Compiler(jsCompile);
})();

module.exports = {
  less: less,
  js: js
};
