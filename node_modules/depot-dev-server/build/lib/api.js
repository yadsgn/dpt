var Promise, R, bodyParser, createBlock, endsWith, express, fs, isDirectory, listDirs, listVisibleDirs, path, readDirP, readFileP, readJSON, startsWith, statP;

fs = require('fs');

path = require('path');

express = require('express');

bodyParser = require('body-parser');

Promise = require('bluebird');

R = require('ramda');

createBlock = require('./create-block');

readDirP = Promise.promisify(fs.readdir);

readFileP = Promise.promisify(fs.readFile);

statP = Promise.promisify(fs.stat);

readJSON = R.pipeP(readFileP, JSON.parse);

startsWith = function(pattern) {
  return function(str) {
    return str.indexOf(pattern) === 0;
  };
};

endsWith = function(pattern) {
  return function(str) {
    return str.lastIndexOf(pattern) === str.length - pattern.length;
  };
};

isDirectory = function(baseDir) {
  return function(dirName) {
    var dir;
    dir = path.resolve(baseDir, dirName);
    return statP(dir).then(function(stat) {
      return stat.isDirectory();
    });
  };
};

listDirs = function(dir) {
  return readDirP(dir).filter(isDirectory(dir));
};

listVisibleDirs = R.pipeP(listDirs, R.reject(startsWith('.')));

module.exports = function(directory) {
  var app;
  app = express();
  app.use(bodyParser.urlencoded({
    extended: false
  }));
  app.set('json spaces', 2);
  app.get('/libraries', function(req, res) {
    return listDirs(directory).then(R.pipeP(R.filter(R.match(/blocks\.(\w+)/)), R.map(R.replace('blocks.', '')), R.map(R.createMapEntry('name')))).map(function(lib) {
      return readJSON(path.resolve(directory, 'blocks.' + lib.name, '.deps/descr.json')).then(function(descr) {
        return R.assoc('current', descr.current)(R.assoc('description', descr.name, lib));
      });
    }).then(function(libs) {
      return res.json(libs);
    });
  });
  app.post('/libraries', function(req, res) {});
  app.get('/libraries/:lib', function(req, res) {
    var blocksPromise, depsDir, descrPath, descrPromise, libDir;
    libDir = path.resolve(directory, "blocks." + req.params.lib);
    depsDir = path.resolve(libDir, '.deps');
    descrPath = path.resolve(depsDir, 'descr.json');
    descrPromise = readJSON(descrPath);
    blocksPromise = readDirP(depsDir).then(R.pipeP(R.filter(endsWith('.json')), R.filter(startsWith(req.params.lib)))).map(function(filename) {
      return readJSON(path.resolve(depsDir, filename)).then(R.pipeP(R.omit(['name', 'version']), R.assoc('version', filename.split('-').slice(-1)[0].split('.').slice(0, -1).join('.'))));
    });
    return Promise.all([descrPromise, blocksPromise]).then(function(_arg) {
      var descr, files;
      descr = _arg[0], files = _arg[1];
      return res.json(R.mixin(descr, {
        description: descr.name,
        name: req.params.lib,
        dependencies: files
      }));
    });
  });
  app.get('/libraries/:lib/blocks', function(req, res) {
    var libDir;
    libDir = path.resolve(directory, "blocks." + req.params.lib);
    return listVisibleDirs(libDir).map(R.createMapEntry('name')).then(function(blocks) {
      return res.json(blocks);
    });
  });
  app.post('/libraries/:lib/blocks', function(req, res) {
    var blockConfig;
    blockConfig = R.pick(['lib', 'block', 'purpose', 'title', 'ver', 'owner'], req.body);
    return createBlock(directory, blockConfig).then(function(data) {
      return res.status(201).json(data);
    })["catch"](function(err) {
      console.error(err);
      return res.status(500).json({
        error: err.message
      });
    });
  });
  app.get('/libraries/:lib/blocks/:block', function(req, res) {
    var blockDir;
    blockDir = path.resolve('blocks.' + req.params.lib, req.params.block);
    return listDirs(blockDir).then(function(versions) {
      return res.json({
        library: req.params.lib,
        name: req.params.block,
        versions: versions
      });
    });
  });
  return app;
};
