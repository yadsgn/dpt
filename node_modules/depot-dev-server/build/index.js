var Block, Cache, File, Promise, R, api, compileFile, compilers, createServer, express, filesToCompile, mime, path, redirectFromBuild, renderBlock;

path = require('path');

express = require('express');

Promise = require('bluebird');

R = require('ramda');

mime = require('./lib/mime');

api = require('./lib/api');

compilers = require('./lib/compilers');

Block = require('./lib/block');

File = require('./lib/file');

Cache = require('./lib/cache');

compileFile = function(opts, filePath) {
  var compiler;
  compiler = (function() {
    switch (path.extname(filePath)) {
      case '.less':
        return compilers.less;
      case '.css':
        return compilers.css;
      case '.js':
        return compilers.js;
    }
  })();
  return compiler.run(opts, filePath);
};

filesToCompile = function(directory, blockFile) {
  var archived, extensions, files, platforms;
  extensions = {
    css: ['less'],
    js: ['js']
  };
  platforms = R.mapAccum((function(acc, x) {
    return [acc.concat([x]), acc.concat([x])];
  }), [], blockFile.platform.split('-'))[1].map(R.join('-')).reverse().concat(['']);
  files = R.flip(R.chain)(extensions[blockFile.extension], function(ext) {
    var withExt;
    withExt = blockFile.changeExtension(ext);
    return platforms.map(function(p) {
      return withExt.changePlatform(p).toPath();
    });
  });
  archived = files.map(function(f) {
    return path.join('.archive/', f);
  });
  return files.concat(archived).map(function(f) {
    return path.join(directory, f);
  });
};

redirectFromBuild = function(req, res) {
  return res.redirect('/' + req.path.split('/').slice(2).join('/'));
};

renderBlock = function(directory, cache) {
  return function(req, res) {
    var cacheEntry, from, recompile, substitute, to, _ref;
    if (req.query.substitute != null) {
      _ref = req.query.substitute.slice(1, -1).split('/'), from = _ref[0], to = _ref[1];
      substitute = {
        from: from,
        to: to
      };
    }
    recompile = function() {
      var blockFile, filePaths, opts;
      blockFile = Block.BlockFile.fromPath(req.path);
      filePaths = filesToCompile(directory, blockFile);
      opts = {
        platform: blockFile.platform,
        substitute: substitute
      };
      return File.withFirstExistent(R.partial(compileFile, opts))(filePaths).then(function(_arg) {
        var content, files;
        content = _arg.content, files = _arg.files;
        cache.update(req.originalUrl, new Cache.Entry(content, files));
        return res.type(mime(req.path)).send(content);
      })["catch"](function(err) {
        console.error(err);
        return res.status(500).send('Error: ' + err.message);
      });
    };
    if (cache.has(req.originalUrl)) {
      cacheEntry = cache.get(req.originalUrl);
      return cacheEntry.isValid().then(function(valid) {
        if (valid) {
          return res.type(mime(req.path)).send(cacheEntry.content);
        } else {
          return recompile();
        }
      });
    } else {
      return recompile();
    }
  };
};

createServer = function(directory) {
  var app, cache;
  app = express();
  app.use('/api/beta', api(directory));
  cache = new Cache();
  app.get('/.build/blocks.*/*/*/*.(js|css)', renderBlock(directory, cache));
  app.get('/.build/*', redirectFromBuild);
  app.use(express["static"](directory));
  return app;
};

module.exports = {
  createServer: createServer
};
